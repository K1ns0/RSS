{
  "sources": [
    {
      "title": "离别歌",
      "feedUrl": "https://www.leavesongs.com/feed/",
      "siteUrl": "https://www.leavesongs.com",
      "articles": [
        {
          "id": "https://www.leavesongs.com/PENETRATION/defcon-29-threefactooorx-writeup.html",
          "author": "phithon",
          "description": "defcon 29就这一道Web题目，说实话也没学到啥东西，唯一学到的就是勿钻牛角尖，及时调整策略。此题严格",
          "link": "https://www.leavesongs.com/PENETRATION/defcon-29-threefactooorx-writeup.html",
          "publishedOn": "2021-09-08T07:11:29.253Z",
          "wordCount": 672,
          "title": "JavaScript逆向调试记 —— defcon threefactooorx writeup"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/diy-commons-collections6-poc.html",
          "author": "phithon",
          "description": "这是代码审计知识星球中《Java安全漫谈》的第十二篇文章。",
          "link": "https://www.leavesongs.com/PENETRATION/diy-commons-collections6-poc.html",
          "publishedOn": "2021-09-08T07:11:27.106Z",
          "wordCount": 559,
          "title": "手工编写简化版CommonsCollections6，带你实现Java8全版本反序列化利用"
        },
        {
          "id": "https://www.leavesongs.com/PHP/baota-phpmyadmin-unauthentication-analysis.html",
          "author": "phithon",
          "description": "本文2020年8月24日发表于代码审计公众号\n周日晚，某群里突然发布了一则消息，宝塔面板的phpmyadmin存在未授权访问漏洞的紧急漏洞预警，并给出了一大批存在漏洞的URL：\n\n随便点开其中一个，赫然就是一个大大的phpmyadmin后台管理页面，无需任何认证与登录。当然，随后各种神图神事也都刷爆了社交网络，作为一个冷静安全研究者，我对此当然是一笑置之，但是这个漏洞的原因我还是颇感兴趣的，所",
          "link": "https://www.leavesongs.com/PHP/baota-phpmyadmin-unauthentication-analysis.html",
          "publishedOn": "2021-09-08T07:11:10.944Z",
          "wordCount": 332,
          "title": "宝塔面板phpMyAdmin未授权访问漏洞是个低级错误吗？"
        },
        {
          "id": "https://www.leavesongs.com/PYTHON/django-timezone-detail.html",
          "author": "phithon",
          "description": "在开发国际化网站的时候，难免会与时区打交道，通用CMS更是如此，毕竟其潜在用户可能是来自于全球各地的。Django在时区这个问题上下了不少功夫，但是很多资深的开发者都有可能尚未完全屡清楚Django中各种时间的实际意义和使用方法，导致写出错误的代码；作为安全研究人员，时区问题也可能和一些安全问题挂钩，比如优惠券的过期时间、订单的下单与取消时间等，如果没有考虑时区问题，有可能将导致一些逻辑漏洞。\n本",
          "link": "https://www.leavesongs.com/PYTHON/django-timezone-detail.html",
          "publishedOn": "2021-09-08T07:11:10.877Z",
          "wordCount": 280,
          "title": "Django中与时区相关的安全问题"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html",
          "author": "phithon",
          "description": "com.sun.org.apache.bcel.internal.util.ClassLoader是常常在构造漏洞利用POC时用到的类。但是，我前几天在写《Java安全漫谈》的时候，偶然发现我环境中的com.sun.org.apache.bcel.internal.util.ClassLoader类找不到了，本文就带大家来找找BCEL ClassLoader。\n0x01 BCEL从哪里来\n首先，B",
          "link": "https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html",
          "publishedOn": "2021-09-08T07:11:10.662Z",
          "wordCount": 399,
          "title": "BCEL ClassLoader去哪了"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/the-collision-of-containers-and-the-cloud-pentesting-a-MinIO.html",
          "author": "phithon",
          "description": "事先声明：本次测试过程完全处于本地或授权环境，仅供学习与参考，不存在未授权测试过程。本文提到的漏洞《MinIO未授权SSRF漏洞（CVE-2021-21287）》已经修复，也请读者勿使用该漏洞进行未授权测试，否则作者不承担任何责任\n(English edition)\n随着工作和生活中的一些环境逐渐往云端迁移，对象存储的需求也逐渐多了起来，MinIO就是一款支持部署在私有云的开源对象存储系统。M",
          "link": "https://www.leavesongs.com/PENETRATION/the-collision-of-containers-and-the-cloud-pentesting-a-MinIO.html",
          "publishedOn": "2021-09-08T07:11:10.646Z",
          "wordCount": 632,
          "title": "CVE-2021-21287: 容器与云的碰撞——一次对MinIO的测试"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/a-tour-of-tui-editor-xss.html",
          "author": "phithon",
          "description": "TOAST Tui Editor是一款富文本Markdown编辑器，用于给HTML表单提供Markdown和富文本编写支持。最近我们在工作中需要使用到它，相比于其他一些Markdown编辑器，它更新迭代较快，功能也比较强大。另外，它不但提供编辑器功能，也提供了渲染功能（Viewer），也就是说编辑和显示都可以使用Tui Editor搞定。\nTui Editor的Viewer功能使用方法很简单：\ni",
          "link": "https://www.leavesongs.com/PENETRATION/a-tour-of-tui-editor-xss.html",
          "publishedOn": "2021-09-08T07:11:10.437Z",
          "wordCount": 520,
          "title": "一次对 Tui Editor XSS 的挖掘与分析"
        },
        {
          "id": "https://www.leavesongs.com/PHP/php-8-0-release.html",
          "author": "phithon",
          "description": "本文首发在我的『代码审计』公众号，欢迎关注\n经历了近半年的alpha版本测试后，PHP在2020年11月26号正式发布了8.0版本：https://www.php.net/releases/8.0/en.php\n今天我们就来浏览一下PHP 8.0中出现的主要特性，以及它给我们安全研究人员带来的挑战。\n命名参数 Named Arguments\nPHP 8 以前，如果我们需要给一个函数的第N个参数",
          "link": "https://www.leavesongs.com/PHP/php-8-0-release.html",
          "publishedOn": "2021-09-08T07:11:10.408Z",
          "wordCount": 476,
          "title": "有安全研究者混入了PHP 8.0开发组！"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/cachet-from-laravel-sqli-to-bug-bounty.html",
          "author": "phithon",
          "description": "事先声明：本次测试过程完全处于本地或授权环境，仅供学习与参考，不存在未授权测试过程。本文提到的漏洞《Cachet SQL注入漏洞（CVE-2021-39165）》已经修复，也请读者勿使用该漏洞进行未授权测试，否则作者不承担任何责任\n0x01 故事的起源\n一个百无聊赖的周日晚上，我在知识星球闲逛，发现有一个匿名用户一连向我提出了两个问题：\n\n本来不是很想回答这两个问题，一是感觉比较基础，二是现在",
          "link": "https://www.leavesongs.com/PENETRATION/cachet-from-laravel-sqli-to-bug-bounty.html",
          "publishedOn": "2021-09-08T07:11:10.280Z",
          "wordCount": 1167,
          "title": "CVE-2021-39165: 从一个Laravel SQL注入漏洞开始的Bug Bounty之旅"
        },
        {
          "id": "https://www.leavesongs.com/PENETRATION/commons-beanutils-without-commons-collections.html",
          "author": "phithon",
          "description": "这是代码审计知识星球中Java安全漫谈的第十七篇文章。完整文章列表与相关代码请参考：https://github.com/phith0n/JavaThings\n上一篇文章里，我们认识了java.util.PriorityQueue，它在Java中是一个优先队列，队列中每一个元素有自己的优先级。在反序列化这个对象时，为了保证队列顺序，会进行重排序的操作，而排序就涉及到大小比较，进而执行java.",
          "link": "https://www.leavesongs.com/PENETRATION/commons-beanutils-without-commons-collections.html",
          "publishedOn": "2021-09-08T07:11:10.208Z",
          "wordCount": 737,
          "title": "CommonsBeanutils与无commons-collections的Shiro反序列化利用"
        }
      ]
    },
    {
      "title": "Armin Ronacher's Thoughts and Writings",
      "feedUrl": "https://lucumr.pocoo.org/feed.atom",
      "siteUrl": "http://lucumr.pocoo.org/",
      "articles": []
    },
    {
      "title": "ArthurChiao's Blog",
      "feedUrl": "http://arthurchiao.art/feed.xml",
      "siteUrl": "https://arthurchiao.github.io/",
      "articles": [
        {
          "id": "https://arthurchiao.github.io/blog/cgroupv2-zh/",
          "author": null,
          "description": "译者序\n本文翻译自 2021 年 Linux 5.10 内核文档：\nControl Group v2，\n它是描述 cgroupv2 用户空间侧的设计、接口和规范的权威文档。\n原文非常全面详细，本文只翻译了目前感兴趣的部分，其他部分保留原文。\n另外，由于技术规范的描述比较抽象，因此翻译时加了一些系统测试输出、内核代码片段和\n链接，便于更好理解。\n由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\n以下是译文。\n译者序\n1 引言    \n1.1 术语\n1.2 cgroup 是什么？        \n1.2.1 cgroup 组成部分\n1.2.2 进程/线程与 cgroup 关系\n1.2.3 控制器\n2 基础操作    \n2.1 挂载（mounting）        \n2.1.1 控制器与 v1/v2 绑定关系\n2.1.2 示例：ubuntu 20.04 同时挂载 cgroupv1/cgroupv2（译注）\n2.1.3 控制器在 v1 和 v2 之间切换\n2.1.4 cgroupv2 mount 选项\n2.2 组织（organizing）进程和线程        \n2.2.1 进程：创建/删除/移动/查看 cgroup\n2.2.2 线程            \n将 cgroup 改成 theaded 模式（单向/不可逆操作）\n2.3 [Un]populated Notification（进程退出通知）\n2.3 管理控制器（controlling controllers）        \n2.3.1 启用和禁用\n2.3.2 自顶向下启用（top-down constraint）\n2.3.3 将资源分给 children 时，parent cgroup 内不能有进程（no internal process）\n2.4 Delegation（委派）        \n2…",
          "link": "https://arthurchiao.github.io/blog/cgroupv2-zh/",
          "publishedOn": "2021-09-10T00:00:00.000Z",
          "wordCount": 11922,
          "title": "[译] Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）"
        },
        {
          "id": "https://arthurchiao.github.io/blog/intro-to-io-uring-zh/",
          "author": null,
          "description": "译者序\n本文组合翻译了以下两篇文章的干货部分，作为 io_uring 相关的入门参考：\nHow io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020\nAn Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020\nio_uring 是 2019 年 Linux 5.1 内核首次引入的高性能\n异步 I/O 框架，能显著加速 I/O 密集型应用的性能。\n但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，\n那 io_uring 并不会带来太大的性能提升 —— 根据原文测试（以及我们\n自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则\n切换成 io_uring 代价可能也挺大，因为要\n重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。\n既然性能跟传统 AIO 差不多，那为什么还称 io_uring 为革命性技术呢？\n它首先和最大的贡献在于：统一了 Linux 异步 I/O 框架，\nLinux AIO 只支持 direct I/O 模式的存储文件\n（storage file），而且主要用在数据库这一细分领域；\nio_uring 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用\n（accept/openat/stat/...），而非仅限于 read/write 系统调用。\n在设计上是真正的异步 I/O，作为对比，Linux AIO 虽然也\n是异步的，但仍然可能会阻塞，某些情况下的行为也无法预测；\n灵活性和可扩展性非常好，甚至能基于 io_uring 重新所有系统调用，而 Linux AIO…",
          "link": "https://arthurchiao.github.io/blog/intro-to-io-uring-zh/",
          "publishedOn": "2021-09-01T00:00:00.000Z",
          "wordCount": 3075,
          "title": "[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）"
        },
        {
          "id": "https://arthurchiao.github.io/blog/linux-socket-filtering-aka-bpf-zh/",
          "author": null,
          "description": "译者序\n本文翻译自 2021 年 Linux 5.10 内核文档：\nLinux Socket Filtering aka Berkeley Packet Filter (BPF)，\n文档源码见 Documentation/networking/filter.rst。\nLinux Socket Filtering (LSF) 是最初将 BSD 系统上的数据包过滤技术\nBPF（伯克利包过滤器）移植到 Linux 系统时使用的名称，但后来大家还是更多称呼其为\nBPF（aka：as known as）。本文介绍了 Linux BPF 的一些\n底层设计和实现（包括 cBPF 和 eBPF），可作为\nCilium：BPF 和 XDP 参考指南（2021）\n的很好补充，这两篇可能是目前除了内核源码之外，学习 BPF 的最全/最好参考。\n本文适合有一定 BPF 经验的开发者阅读，不适合初学者。\n由于内核文档更新不是非常及时，文中部分内容已经与 5.10 代码对不上，因此（少量）\n过时内容在翻译时略去了。另外，为文中的大部分 BPF 汇编 / x86_64 汇编加了注释，\n并插入了一些 5.10 代码片段或链接，方便更深入理解。\n由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\n以下是译文。\n译者序\n————————————————————————\ncBPF 相关内容\n————————————————————————\n1 cBPF 引言    \n1.1 LSF (cBPF) 与 BSD BPF\n1.2 ATTACH/DETACH/LOCK 给定过滤器\n1.3 LSF/BPF 使用场景\n1.4 cBPF 经典论文\n2 cBPF 数据结构    \n2.1 struct sock_filter\n2.2 struct sock_fprog\n3 cBPF 示例：libpcap 过滤…",
          "link": "https://arthurchiao.github.io/blog/linux-socket-filtering-aka-bpf-zh/",
          "publishedOn": "2021-08-27T00:00:00.000Z",
          "wordCount": 7071,
          "title": "[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）"
        },
        {
          "id": "https://arthurchiao.github.io/blog/ebpf-assembly-with-llvm-zh/",
          "author": null,
          "description": "译者序\n本文翻译自 2020 年 Quentin Monnet 的一篇英文博客：\neBPF assembly with LLVM。\nQuentin Monnet 是 Cilium 开发者之一，此前也在从事网络、eBPF 相关的开发。\n翻译已获得 Quentin Monnet 授权。\n文章介绍了如何直接基于 LLVM eBPF 汇编开发 BPF 程序，虽然给出的\n两个例子极其简单，但其流程对于开发更大的程序也是适用的。为什么不用 C，而用汇编\n这么不友好的编程方式呢？至少有两个特殊场景：\n测试特定的 eBPF 指令流\n对程序的某个特定部分进行深度调优\n原文历时（开头之后拖延）了好几年，因此文中存在一些（文件名等）前后不一致之处，翻译时已经改正\n（交流之后，作者已经修正）；另外，译文基于 clang/llvm 10.0 验证了其中的每个步骤，因此代码、输出等与原文不完全一致。\n由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\n以下是译文。\n译者序\n1 引言    \n1.1 主流开发方式：从 C 代码直接生成 eBPF 字节码\n1.2 特殊场景需求：eBPF 汇编编程更合适\n1.3 几种 eBPF 汇编编程方式\n2 Clang/LLVM 编译 eBPF 基础    \n2.1 将 C 程序编译成 BPF 目标文件\n1.2 查看 ELF 文件中的 eBPF 字节码\n3 方式一：C 生成 eBPF 汇编 + 手工修改汇编    \n3.1 将 C 编译成 eBPF 汇编（clang）\n3.2 手工修改汇编程序\n3.3 将汇编程序 assemble 成 ELF 对象文件（llvm-mc）\n3.4 查看对象文件中的 eBPF 字节码（readelf）\n3.5 以更加人类可读的方式查看 eBPF 字节码（llvm-objdump -d）\n3.6 编译时嵌入调试符号或 C 源…",
          "link": "https://arthurchiao.github.io/blog/ebpf-assembly-with-llvm-zh/",
          "publishedOn": "2021-08-15T00:00:00.000Z",
          "wordCount": 1042,
          "title": "[译] LLVM eBPF 汇编编程（2020）"
        }
      ]
    },
    {
      "title": "Coding (In)Security",
      "feedUrl": "http://coding-insecurity.blogspot.com/feeds/posts/default",
      "siteUrl": "http://coding-insecurity.blogspot.com/",
      "articles": []
    }
  ],
  "cliVersion": "1.11.0"
}